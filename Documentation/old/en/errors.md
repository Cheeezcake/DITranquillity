# Исключения

В этой главе перечислены все ошибки, которые может кинуть библиотека. Каждая ошибка сделана так, чтобы дать как можно более подробную информацию о том, что произошло.


#### `DIError.typeIsNotFound(type:)`
**Кратко:**  
Нет регистрации по указанному типу.  
**Когда может возникнуть:**  
При вызове метода `resolve` у контейнера  
**Параметры:**  
type - тип, для которого не удалось найти регистрацию  
**Описание:**  
Возникает в случае если тип, который запрашивается, не был зарегистрирован. Чаще всего причиной ошибки является невнимательность.

#### `DIError.typeIsNotFoundForName(type:,name:,typesInfo:)`
**Кратко:**  
Нет регистрации по указанному типу и имени.  
**Когда может возникнуть:**  
При вызове метода `resolve` с параметром `name` у контейнера  
**Параметры:**  
type - тип, для которого не удалось найти регистрация с указанным именем  
name - имя, для которого не удалось найти регистрацию  
typesInfo - описание регистраций, которые были найдены для данного типа  
**Описание:**  
Возникает в случае если для запрашиваемого типа не зарегистрировано указанное имя. При этом если такой тип полностью не зарегистрирован в системе, то кинется `typeIsNotFound`.

#### `DIError.notSpecifiedInitializationMethodFor(typeInfo:)`
**Кратко:**  
Не объявлен метод инициализации и при этом при регистрации не объявлено, что он может отсутствовать.  
**Когда может возникнуть:**  
При сборке контейнера  
**Параметры:**  
typeInfo - описание регистрации, у которой нет метода инициализации  
**Описание:**  
Возникает, в случае если при регистрации не указали метод инициализации или не указали, что он может отсутствовать.

#### `DIError.initializationMethodWithSignatureIsNotFoundFor(typeInfo:,signature:)`
**Кратко:**  
Нет метода инициализации с заданной сигнатурой для типа.  
**Когда может возникнуть:**  
При вызове метода `resolve` у контейнера  
**Параметры:**  
typeInfo - описание регистрации, которое было выбрано на основании указанного типа  
signature - сигнатура метода, которую не удалось найти  
**Описание:**  
Возникает, в случае если не удалось найти метод инициализации с заданной сигнатурой. Под сигнатурой подразумевается количество и тип входящих параметров в метод инициализации.

#### `DIError.pluralSpecifiedDefaultType(type:, typesInfo:)`
**Кратко:**  
При множественной регистрации для одного типа указано более одной регистрации по умолчанию.  
**Когда может возникнуть:**  
При сборке контейнера  
**Параметры:**  
type - тип, для которого указано несколько регистраций с указанием "по умолчанию"  
typesInfo - информация обо всех регистрация для этого типа  
**Описание:**  
Возникает если при разных регистрация для одного и того же типа указано, что они являются "по умолчанию" и таких регистраций более 1.

#### `DIError.defaultTypeIsNotSpecified(type:,typesInfo:)`
**Кратко:**  
Не указана регистрация по умолчанию.  
**Когда может возникнуть:**  
При вызове метода `resolve` у контейнера  
**Параметры:**  
type - тип, для которого не указана регистрация по умолчанию  
typesInfo - информация обо всех регистрациях для этого типа   
**Описание:**  
Возникает, если для типа есть более одной регистрации и библиотека не располагает данными чтобы выбрать какой именно ей нужен - нету регистрации отмеченной по умолчанию.

#### `DIError.intersectionNamesForType(type:, names:, typesInfo:)`
**Кратко:**  
Для типа есть разные регистрации с одинаковыми именами.  
**Когда может возникнуть:**  
При сборке контейнера  
**Параметры:**  
type - тип, для которого пересекаются имена  
names - множество имен, которые пересекаются  
typesInfo - информация обо всех регистрациях для этого типа  
**Описание:**  
Возникает, если для типа есть более одной регистрации и у части этих регистраций указаны имена, так что эти имена пересекаются.

#### `DIError.typeIsIncorrect(requestedType:, realType:, typeInfo:)`
**Кратко:**  
Созданный тип объекта, не совпадает с типом, который был запрошен.  
**Когда может возникнуть:**  
При вызове метода `resolve` у контейнера  
**Параметры:**  
requestedType - запрашиваемый тип  
realType - тип объекта, который был создан  
typeInfo - информация о регистрации, которая использовалась для создания объекта по типу  
**Описание:**  
Из-за того что `as` может не проверять правильность указанного типа, могут возникнуть ситуации, что создаваемый тип находиться в другой иерархии классов, нежели тип по которому он нашелся. Ошибка может возникнуть только при использовании `as`, поэтому будьте внимательны, так как обнаружиться ошибка только во время исполнения, или используйте функцию `check{$0}` дабы перенести проверку ошибок на компилятор.

#### `DIError.recursiveInitialization(typeInfo:)`
**Кратко:**  
Рекурсивная инициализация объекта.  
**Когда может возникнуть:**  
При вызове метода `resolve` у контейнера  
**Параметры:**  
typeInfo - информация о регистрации, которая содержит рекурсивную инициализацию  
**Описание:**  
Ошибка возникает, если метод инициализации запрашивает создание самого себя или же это происходит через несколько уровней создания.
  
  
#### `DIError.noAccess(typesInfo:,accessModules:)`
**Кратко:**  
Нет доступа из данного места в программе к запрашиваемому типу.  
**Когда может возникнуть:**  
При вызове метода `resolve` у контейнера  
**Параметры:**  
typesInfo - информация обо всех регистрациях, которые есть для этого типа  
accessModules - имена всех модулей, из которых есть доступ к этому типу
**Описание:**  
Ошибка возникает если пытаться вызвать получение объекта из соседнего модуля, при этом эти модуль не является зависимым от модуля, из которого запрашивается тип, или этот тип находится в `internal` компоненте.

#### `DIError.build(errors:)`
**Кратко:**  
Ошибка для собирания других ошибок  
**Когда может возникнуть:**  
При сборке контейнера  
**Параметры:**  
errors - массив других ошибок  
**Описание:**  
Ошибка сама по себе таковой не является - это контейнер, который выдается наружу, если была обнаружена хотя бы одна ошибка во время сборки контейнера.

#### `DIError.stack(type:,child:,resolveStyle:)`
**Кратко:**  
Ошибка для запоминания стека вызовов  
**Когда может возникнуть:**  
При вызове метода `resolve` у контейнера
**Параметры:**  
type - тип, который разрешался
child - ошибка, которая возникла раньше и инициализировала создание этой
resolveStyle - каким образом пытался получиться объект: `one`, `many`, `byName(name:)`
**Описание:**  
Ошибка сама по себе таковой не является - это ошибка создается, если была создана другая ошибка. Нужна для более точного понимания, какой был стек вызовов при получении некоторого типа.

#### `DIError.byCall(file:,line:,function:,stack:)`
**Кратко:**  
Ошибка для запоминания точки, откуда начинался вызов 
**Когда может возникнуть:**  
При вызове метода `resolve` у контейнера
**Параметры:**  
file,line, function - файл, строчка кода, функция из которой началось получение объекта
stack - сама ошибка
**Описание:**  
Ошибка сама по себе таковой не является - это ошибка создается, если была создана другая ошибка, чаще всего `DIError.stack`. Нужна для более точного понимания, из какого места в коде пользователя изначально было вызвано получение объекта.

#### `DIError.whileCreateSingleton(typeInfo:,stack:)`
**Кратко:**  
Обертка если ошибка возникла во время создания синглетон объекта.  
**Когда может возникнуть:**  
При создании контейнера  
**Параметры:**  
typeInfo - информация о регистрации, для которой не удалось создать синглетон  
stack - стек ошибок, которые возникли при создании объекта
**Описание:**  
Ошибка возникает, если при создании контейнера не удалось создать объект со временем жизни `.single`.

#### [Главная](main.md)
#### [Предыдущая глава "Логирование"](log.md#Логирование)
#### [Следующая глава "Примеры"](sample.md#Примеры)
