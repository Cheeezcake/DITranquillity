# Регистрация
Любая регистрация происходит с помощью ключевого метода `register`, у экземпляра класса `DIContainerBuilder`. Прежде чем начать регистрировать что либо, нужно в системе создать как миниум один экземпляр класса `DIContainerBuilder`:
```Swift
let builder = DIContainerBuilder()
```
С этого места и далее, если в документации встречается объект с именем `builder`, то это означает, что это экземпляр класса `DIContainerBuilder`.

Существует три базовых регистрации:
* Тип `register(type:)`
* Компонент `register(component:)`
* Модуль `register(module:)`
Некоторые части системы, дополняют регистрацию дополнительными возможностями, о которых будет описана в главе про эту часть.

## Регистрация типа
Самая часто встречаемая регистрация. Далее в этой главе будет рассказано только о регистрации по типу. Другие способы регистрации, можно найти в главах: [компонент](component.md), [модуль](module.md), [storyboard](storyboard.md)

При такой регистрации системе сообщается тип, по которому будет доступен объект.
!! При разделении регистрации на две части: объявление типа и объявление метода инициализации, настоятельно рекомендую указывать один и тот же тип. Это не обязательное условие, так как при объявлении типа можно указать любой родительский класс. Но для лучшей поддержки всех дальнейших операций, лучше чтобы типы совпадали.

Для того чтобы в системе зарегистрировать тип нужно указать его в ключевом методе:
```Swift
builder.register(type: Cat.self) // Регистрация типа `Cat`
```
Это не единственный способ регистрации по типу остальные будут разобраны ниже.

## Указание метода инициализации
Предыдущий код не может считаться полным, так как библиотека не умеет автоматически выводить метод инициализации для любого типа. Чтобы тип был полностью зарегистрирован в системе, нужно указать метод инициализации. Для этого можно использовать closure в котором инициализировать объект. Если метод инициализации принимает на вход только простые зависимости, то можно указать сам метод инициализации:
```Swift
builder.register(type: Cat.self).initial{ Cat() } // через closure
builder.register(type: Cat.self).initial(Cat.init) // через метод инициализации
```

Такой способ является универсальным, и благодаря статической типизации нельзя указать не тот создаваемый объект, но имеет недостаток - тип указывается дважды. Поэтому существует короткая запись:
```Swift
builder.register{ Cat() } // через closure
builder.register(type: Cat.init) // через метод инициализации
```

## Указание дочерних типов
Помимо указанного типа при регистрации можно указать дочерние типы, по которому будет доступен объект. Чаще всего дочерними типами выступают протоколы. 

Указание дочернего типа, происходит с помощью метода `as`:
```Swift
builder.register(type: Cat.self).as(Animal.self)...
```

!!! Если указан дочерний тип, то разрешение зависимостей возможно только по этому типу - базовый тип будет утерян, если не указано обратного. Для примера выше объект будет доступен только по имени `Animal`.
Чтобы объект `Cat` был доступен по типу `Cat` и `Animal`, можно или продублировать тип, что не желательно, или воспользоваться методом `as(.self)`:
```Swift
builder.register(type: Cat.self).as(.self).as(Animal.self)....
```

Во второй версии библиотеки, синтаксис функции `as` стал более сложным, он обязывает проверить тип. Если этого не сделать запись будет проигнорирована. Чтобы проверить тип нужно использовать функцию `check`:
```Swift
builder.register(type: Cat.self).as(Animal.self).check{$0}
```

Если вы любите стрелять себе в ногу, или вы решили не следовать совету про указание одного и того же типа в регистрации и методе инициализации, существует способ указать дочерний тип без проверки, правда в этом случае нельзя также гарантировать что он будет дочерним:
```Swift
builder.register(type: Cat.self).as(Animal.self).unsafe()
```

Помимо этого функцию с проверкой, можно переписать более коротким образом - без указания функции `check`:
```Swift
builder.register(type: Cat.self).as(Animal.self, check: {$0})
builder.register(type: Cat.self).as(Animal.self){$0}
```
!! Обращаю внимание, что отдельная функция была сделано не просто так, а по причине необработанности компилятора Swift - в случаи отдельной функции если тип не валиден, то компилятор так и напишет, во втором же случае он напишет, что функция as с такими аргументами не найдена.

## Разрешение зависимостей при инициализации
Если класс имеет зависимости от других классов, то их надо указать. Указать зависимости можно тремя способами:
* Через метод инициализации (конструктор)
* Через свойства
* Через любой другой метод

Для указания зависимостей, нужно получить контейнер, и у него уже попросить интересующий нас объект:
```Swift
builder.register(type: Home.self).initial { (container) in try Home(cat: container.resolve()) }
builder.register{ (container) in try Home(cat: container.resolve()) }
```
Более подробную информацию можно прочитать в главе [Разрешение зависимостей](resolve.md)

Если инициализация объекта состоит только из объектов, которые нужно внедрять, то можно воспользоваться более короткой записью:
```Swift
builder.register(type: Home.self).initial(Home.init(cat:))
builder.register(type: Home.init(cat:))
```

И существует вариант, записи, являющийся чем-то средним между первым и вторым:
```Swift
builder.register(type: Home.self).initial{ Home(cat:$0) }
builder.register{ Home(cat:$0) }
```

!! Внимание. Второй и третий вариант не поддерживает множественное разрешение зависимостей, также как и опциональное. Внутри всегда используется обычный `try` и обычный метод `resolve`.

## Разрешение зависимостей после инициализации
Для указания зависимостей через свойства или любой другой метод, существует специальный метод `injection`. Подробно о нем можно прочитать в следующей главе: ["Внедрение"](injection.md)

#### [Главная](main.md)
#### [Следующая глава "Внедрение"](injection.md#Внедрение)
