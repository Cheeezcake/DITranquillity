# Получение графа
Получение графа одна из важных особенностей этой библиотеки. Так как возможность получать граф, позволяет его и проверить на корректность. Тема проверки графа раскрыта в отдельной [главе](graph_validation.md), а в этой маленькой главе остановимся на том как получить граф, и какую инфомацию он хранит.

Для получения графа зависимостей у контейнера нужно вызвать функцию `makeGraph()` которая быстро сконвертирует внутренний формат хранения данных в удобный для использования. Функция возвращает тип `DIGraph`:
```Swift
let graph: DIGraph = container.makeGraph()
```

> Граф создается для текущего состояния, и автоматически не меняется в случае регистрации дополнительных зависимостей.

## DIGraph
Граф представлен [списком смежности](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D1%81%D0%BC%D0%B5%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8) и имеет следующую структуру:
```Swift
typealias AdjacencyList = [[(edge: DIEdge, toIndices: [Int])]]
let vertices: [DIVertex]
let adjacencyList: AdjacencyList
```
При этом гарантируется что количество вершин равно размеру списка смежности.

Вершины представлены в виде массива, и к ним можно и нужно обращаться по индексу.

Список смежности представлен как массив где каждый элемент соответствует вершине. Для каждого элемента в массиве содержится еще один массив - список ребер. При этом видно что ребра представлены не в типичном виде - есть само ребро, и отдельно массив индексов куда возможен переход. Оно описано не как структура для удобства использования. Да по одному ребру возможен переход в несколько вершин. Это сделано специально ради возможности правильно описать модификатор [many](../Core/modificated_injection.md#Множественное-внедрение). 

> если вы не используете many и ваш граф корректен, то в массиве всегда будет один элемент.

Если нужно обойти весь граф, начиная с некоторой вершины, то достаточно воспользоваться  adjacencyList и использовать `toIndices`. 

Например если мы хотим с помощью обхода в ширину обойти все достижимые вершины, начиная с некоторой, то можно написать следующую функцию:
```Swift
let graph: DIGraph = container.makeGraph()

func bfs(from startIndex: Int) {
  var visited: Set<Int> = []
  var stack: [Int] = [startIndex]
  while let fromIndex = stack.first {
    stack.removeFirst()
    visited.insert(fromIndex)
    
    for toIndex in graph.adjacencyList[fromIndex].flatMap({ $0.toIndices }) {
      if !visited.contains(toIndex) {
        stack.append(toIndex)
      }
    }
  }
  
  return visited
}
```
Функция при этом возвращает все достижимые вершины из заданной.

Но просто бегать по графу не интересно - давайте разбираться какие данные хранятся в нем по мимо информации о переходе.

## DIVertex
Вершина графа. Вершина графа может быть трех видов: компонент, аргумент, неизвестный тип:
```Swift
enum DIVertex: Hashable {
  case component(DIComponentVertex)
  case argument(DIArgumentVertex)
  case unknown(DIUnknownVertex)
}
```
Компоненты берутся из container-а и находятся вначале списка вершин. Аргументы и неизвестный тип находятся дальше но между ними порядка нет. 

Аргумент создается каждый раз когда в компоненте встречается [внедрение аргумента](../Core/modificated_injection.md#Аргумент). Даже если типы у аргументов совпадают, то это будет два разных аргумента.

Неизвестный тип создается каждый раз когда для внедрения не удалось найти подходящий компонент. Даже если типы у неизвестного типа совпадают, то это будет два разных неизвестных типа.

Аргумент и неизвестный тип имеют одинаковую структуру:
```Swift
struct DIArgumentVertex/DIUnknownVertex: Hashable {
  let type: DIAType
}
```
И просто хранят в себе обычный swift тип.

### DIComponentVertex
Вершина графа представленная компонентом. Содержит описание регистрации компонента. Уникальность обеспечивается компонентом - на каждую регистрацию в коде приходится один компонент и одна вершина. Их можно скопировать, но они будут равны.

Структура:
```Swift
let componentInfo: DIComponentInfo
let lifeTime: DILifeTime
let isDefault: Bool
let canInitialize: Bool

let framework: DIFramework.Type?
let part: DIPart.Type?
```
Первым идет описание компонента с точки зрения уникальности - это регистрируемый тип, файл в котором происходит регистрация и строчка кода. 

После идет время жизни - тоже самое что было указано при регистрации. и также флаг `isDefault` который задается в случае если при регистрации была вызвана функция `default()`

Далее флаг говорящий о том можно ли компонент инициализировать, или можно только внедрять в него зависимости по средствам функции `container.inject(into:...`. Компонент нельзя иницилиализировать, если не был передан метод инициализации, то есть было написано так: `container.register(Type.self)` где самое важное это `.self`

После идет два значения - фреймворк и часть в которой происходила регистрация. Эта информация очень полезная если у вас Модульное приложение.

На этом описание вершины закончилось, но в дальнейшем возможны изменения/дополнения информации о компоненте.

## DIEdge
Информация о ребре графа, или по другому о зависимости. Имеет следующую структуру:
```Swift
let initial: Bool
let cycle: Bool
let optional: Bool
let many: Bool
let delayed: Bool
let tags: [DITag]
let name: String? 
let type: DIAType
```

По порядку:
* initial - говорит о том, что данная зависимость идет из метода инициализации, а не отдельным внедрением. 
* cycle - говорит о том, что есть указание разрыва цикла. Ну или по другому в коде было написано: `.injection(cycle: true...`.  Если initial истина, то cycle точно лож.
* optional - является ли данная зависимость опциональной. Это возможно если внедряемый тип имеет обычный опционал с точки зрения языка.
* many - является ли данная зависимость [множественным внедрением](../core/modificated_injection.md#Множественное-внедрение).
* delayed - является ли данная зависимость [отложенной](../core/delayed_injection.md). То есть используется или Lazy или Provider.
* tags - массив тэгов по которым производился поиск компонента. [Подробней про тэги](../core/modificated_injection.md#Тэги).
* name - использовалось ли указание дополнительного имени. В отличии от тэгов имя может быть только одно, и не рекомендуемо к использованию.
* type - базовый! тип используемый при поиске куда указывает ребро. Этот тип не содержит информации об опциональности, тэгах и т.п. типах - только база.

Всю эту информацию можно использовать в своих целях.

Библиотека в свою очередь используя эту информацию предлагает такую возможность как [проверка графа зависимостей](graph_validation.md). С этой возможностью я настоятельно рекомендую ознакомится, так как она может сэкономить уйму времени при разработке, и уменьшить количество ошибок во время исполнения.

