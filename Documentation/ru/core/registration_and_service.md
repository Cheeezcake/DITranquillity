# Регистрация

С регистрации начинается работа с контейнером внедрения зависимостей. Суть регистрации - указать какие есть сущности в программе, и как эти сущности связанны друг с другом. В случае с библиотекой DITranquillity регистрация выглядит как еще одно объявление сущности, записанное в правилах библиотеки. По этим причинам такой способ называется "декларативный контейнер", так при его использовании, вы какбы декларируете, что у вас есть.

В коде регистрация сущности всегда начинается с ключевого слова `register`:
```Swift
let container = DIContainer()
container.register(MyClass.init)
```
В круглых скобках указывается тип, который нужно будет создать. Так как создание типа это действие, то надо оставлять информацию не о самом типе, а о методе инициализации этого типа. Для этого можно использовать один из двух вариантов синтаксиса:
```Swift
container.register(MyClass.init)
container.register { MyClass() }
```
Более подробно про отличия этих записей можно почитать в главе [Внедрение/Внедрение через метод инициализации](injection.md#Внедрение_через_метод_инициализации).

> Существует третья запись `container.register(MyClass.self)` которая говорит что надо зарегестрировать тип, но создание объекта будет не обязанностью DI. Такой способ записи используется при работе со Storyboard, или каких-то специфичных кейсов в вашем коде.

Но процесс регистрации, состоит не только с указания сущности, но и еще из нескольких опциональных этапов:
* Указание сервисов
* Указание времени жизни
* Указание зависимостей
* Указание действий после создания объекта
* Указание "по умолчанию"

## Указание сервисов

Часто наша сущность, в особенности классы реализуют протоколы, и иногда даже больше одного. И случается так, что протокол известен другим частям программы, а вот конкретный класс скрыт. Для таких случаев существует указание сервисов. Оно позволяет указать, какие протоколы реализует класс, и тем самым в будущем получить экземпляр класса по этим протоколам.

Синтаксически указание сервисов происходит во время регистрации, с использованием ключевого слова `as`:
```Swift
container.register(Cat.init)
  .as(Animal.self)
  .as(Mammal.self)
  .as(Pet.self)
```
Данная запись будет означать, что животное можно будет получить, по любом из трех описанных типов, то есть:
```Swift
let cat: Cat = container.resolve()
let animal: Animal = container.resolve()
let mammal: Mammal = container.resolve()
let pet: Pet = container.resolve()
```
Все четыре записи создадут кошку. Возникает резонный вопрос, а почему бы не написать так:
```Swift
container.register { Cat() }
container.register { Cat() as Animal }
container.register { Cat() as Mammal }
container.register { Cat() as Pet }
```
Ведь и при такой записи также будут создаваться кошки, по всем 4 типам, но при этом такая запись не требует специфичного синтасиса.

Причина кроется в том, что в сочетании с временем жизни, эти записи становятся не эквивалентные. Самый простой пример - предположим мы хотим чтобы на всю программу существовала всего одна кошка. Но из разных мест к этой кошке обращаются по разным протоколам. Тогда в первом случае возможно указать время жизни объекта, а во втором случае, даже указав время жизни у объектов, мы получим 4 разных кошки. В прочем в некоторых ситуациях это может быть желаемым поведением.

#### Что 
