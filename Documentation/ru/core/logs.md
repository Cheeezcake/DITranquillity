# Логирование

Одна из ключевых особенностей библиотеки, это наличие логов, которые помогают понять что происходило в библиотеки, и самое главное предупреждают о возможных проблемах и указывают на ошибки.

## Настройка
По умолчанию логи выводятся функцией print которая выглядит следующим образом:
```Swift
print("\(logLevel): \(message)")
```
Она выводит уровень логирования, и сообщение. 
>>> Логирование в библиотеки сделано синхронным, поэтому в релизе стоит отключать логи, и не стоит усложнять сильно функцию логирования.

Для того чтобы задать свою функцию логирование, надо обратится к настройкам:
```Swift
DISetting.Log.fun = { level, message in
    NSLog("[\(level)]: \(message)")
}
```
Так как логи могут выводить процесс создания объектов, а объекты создаются вложенно, то для удобства чтения библиотека добавляет табуляцию в сообщение. По умолчанию знаком табуляции является символ таба, но его можно заменить на любой другой:
```Swift
DISetting.Log.tab = ">>"
```

## Уровни логирования
Всего есть 4 уровня логирования: 
* error - ошибка. Если вы увидели в логах подобный уровень, значит программа или уже упала или может упасть в дальнейшем с большой долей вероятности.
* warning - предупреждение. Оно предупреждает о проблемах, но не гарантирует, что они будут. 
* info - информация. Логи информируют о том что, что-то пошло по нежелательному сценарию, но при этом ничему плохого не произойдет.
* verbose - спам :) Логи для описания того что происходит в библиотеки, во время её использования. Нужны для отладки библиотеки, а также в случаи сложных графом зависимости.

И 5 уровень вспомогательный уровень `none` - он полностью отключает логи.

Для того чтобы задать какой уровень логов вы хотите видеть нужно указать один из 5 уровней. Это будет означать, что будут видны все логи до этого уровня включительно. Приоритет логов следующий: `none < error < warning < info < verbose`. Для их задания используется следующих синтаксис:
```Swift
DISetting.Log.level = .verbose
```
По умолчанию стоит уровень логирования `info`

### Описание логов
#### fatal error

* `Can't cast {obj} to optional {type}. For more information see logs.` - В идеале такой ошибки не должно возникать. Если программа упала с такой ошибкой, возможно стоит включить полные логи, и обратится к автору библиотеки приложив логи.
* `Can't resolve type {type}. For more information see logs.` - Не удалось создать объект для указанного типа. Тип при этом не опциональный. Скорей всего это означает, что указанный тип не зарегестрирован, или во время его создания есть серьезные проблемы. Обычно в логах перед этим будет подсказка что именно прошло не так.
* `Registration with type found {type}, but the registration return nil. See {Component}` - библиотека смогла создать объект, но метод создания объекта вернул nil. Такое возможно только если прикладной код зарегестрировал опциональное создание, но при этом есть место, где этот объект внедряется не опционально. По логам можно отыскать куда внедрялся этот компонент.
* `Registration with type found {type}, but the registration return nil.` - Аналог предыдущего, только в этом случае библиотека не смогла понять на каком компоненте произошла проблема. В этом случае надо смотреть логи.
* `Can't cast {objtype} to {type}. For more information see logs.` - Такая ошибка может возникнуть при не верном использовании библиотечной функции `as`. Поэтому стоит посмотреть для типа объекта посмотреть что написано в регистрации.
* `"Please inject this property from DI in file: {file} on line: {line}. ...`  Такая ошибка возникает если вы используется Lazy или Provider инициализируете их пустыми, и при этом потом не заменяет их на аналог из DI контейнера - то есть отсуствует внедрение этих свойст.  

#### error логи

* `Until get argument. Not found extensions for {Component}` - во время получения аргумента оказалось, что его нет. Такая ситуация возможна когда в указанном компоненте есть `arg`, но во время создания объекта аргумент не был передан с помощью возможностей библиотеки. Подробно про аргументы тут: [Модификаторы внедрения](modificated_injection.md#Аргумент)
* `Until make extensions can't find component by type: {type} in file: {file} on line: {line}` - при добавление расширения, не удалось найти компонент для указанного типа. На текущий момент такое возможно только если вы хотите указать передачу компонентов. Для решение проблемы убедить что в контейнере зарегистрирован компонент данного типа.
* `Until make extensions can't choose component by type: {type} in file: {file} on line: {line}` - аналог выше стоящему, но только в этом случае говорится что для указанного типа выбор большой, и библиотека не может определится какой выбрать. Для решения проблемы нужно убрать лишние регистрации.
* (validate) `You have a cycle: ... consisting entirely of initialization methods. Full: ...` Возникает при валидации графа. Говорит что есть цикл состоящий только из методов инициализации - то есть при получении любого объекта из указанного цикла программа упадет из-за бесконецно ициализации. В логах вначале указывает какие типы участвуют в цикле, а потом полную информацию о этих типах. Для решения проблемы надо разорвать цикл отказавшись где-то от внедрения через метод инициализации. Подробно про разрыв циклов тут: [внедрение](injection.md#Внедрение_через_свойства)
*  (validate) `Cycle has no discontinuities. Please install at least one explosion in the cycle: ... using injection(cycle: true) { ... }. Full: ...` Аналог предудущей ошибки, но тут цикл состоит не только из методов инициализации, но в нем учавствует другой способ внедрения. Способ решения эквивалентен предыдущему.
*  (validate) `You cycle: ... consists only of object with lifetime - prototype. Please change at least one object lifetime to another. Full: ...`  Указанный цикл состоит только из `prototype` объектов. Это также приведет к бесконечному созданию, так как каждый объект будет создаваться всегда заново. Для решения проблемы нужно хотябы один объект пометить как `objectGraph`, и желательно тот, с которого будет начинаться получение. Подробно про время жизни тут: [Время жизни](scope_and_lifetime.md)

#### error/warning логи

В зависимости от того является ли тип опциольным или нет в логах может быть как ошибка так и варнинг.
*  (validate) `Not found component for {type} from {Component}` - Не зарегистрирован указанный тип в контейнере, но его пытаются получить из указанного компонента. Для решение проблемы убедитесь что указанный тип регестрируется в DI контейнере или уберите его получение из компонента.
*  (validate) `Not found component for {type} from {Component} that would have initialization methods. Were found: {Components}"` - для указанного типа есть зарегестрированные компоненты (указаны вконце), но не у одного из них нет метода инициализации. При этом этот тип нужен другому компоненту, и его точно нужно иницилазировать. Чаще всего проблема возникает если у указанных компонентов в конце во время регистрации был написан `.self` а не `.init`:  `container.register(Type.self)`
*  (validate) `Ambiguous {type} from {Component} contains in: {Components}` - Слишком большой выбор. Для указанного типа есть несколько регистраций/компонентов и библиотека не способна определить какой из них выбрать. Нужно или добавить `default` или уточнить с помощью имени или тэга, или воспользоваться модульностью. 

#### info логи
* `Not found {type}` - не удалось найти компонент для указанного типа. Очень часто после этой ошибки следующая приведет к фатальной, так как тип окажется не опциональным.
*  (validate) `Not found component for {type} from {Component} that would have initialization methods, but object can maked from cache. Were found: {Components}"` - похожа на вторую ошибку из предыдущей секции, но есть одно важное отличие - в некоторых ситуациях этот компонент мог быть получен раньше, и его получится взять иэ кэша.
*  (validate) `"You cycle: ... contains an object with lifetime - prototype. In some cases this can lead to an udesirable effect.  Full: ...` - Цикл содержит объекты с временем жизни `prototype`. В зависимости от того с какого объекта начинается создание цикла поведение создания объектов может отличатся, что обычно не очень хорошо. Советую проверить точно ли в этом цикле нужны объекты с временем жизни `prototype`

#### verbose логи
Эти логи являются очень полезные для отладки, но их много, и описывать в данном файле не вижу необходимости. Они содержат информацию о том что объект был зарегистрирован, что объект начал/закончил создаваться, объект начали получать, объект был создан.

